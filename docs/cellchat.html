<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Macrophage Pathway Changes: LM vs AN</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background: #0f172a;
            /* Slate 900 */
            min-height: 100vh;
            padding: 20px;
            color: #f1f5f9;
            /* Slate 100 */
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: #1e293b;
            /* Slate 800 */
            border-radius: 12px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            border: 1px solid #334155;
        }

        header {
            background: #1e293b;
            background: linear-gradient(180deg, #1e293b 0%, #0f172a 100%);
            color: white;
            padding: 30px 40px;
            text-align: center;
            border-bottom: 1px solid #334155;
        }

        h1 {
            font-size: 2.2rem;
            font-weight: 700;
            margin-bottom: 8px;
            background: linear-gradient(to right, #818cf8, #c084fc);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            color: #818cf8;
            display: inline-block;
        }

        .subtitle {
            font-size: 1.05rem;
            opacity: 0.8;
            font-weight: 300;
            color: #94a3b8;
        }

        .controls {
            padding: 25px 30px;
            background: #1e293b;
            border-bottom: 1px solid #334155;
            display: flex;
            gap: 25px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-size: 0.85rem;
            font-weight: 600;
            color: #94a3b8;
            letter-spacing: 0.025em;
        }

        select,
        input {
            padding: 10px 14px;
            border: 1px solid #475569;
            border-radius: 6px;
            font-size: 0.9rem;
            background: #0f172a;
            color: #f1f5f9;
            transition: all 0.2s;
        }

        select:focus,
        input:focus {
            outline: none;
            border-color: #818cf8;
            box-shadow: 0 0 0 3px rgba(129, 140, 248, 0.2);
        }

        .btn {
            padding: 10px 20px;
            background: linear-gradient(135deg, #6366f1 0%, #4f46e5 100%);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.2);
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
            filter: brightness(1.1);
        }

        .waterfalls-container {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
            padding: 30px;
            background: #0f172a;
        }

        .waterfall-section {
            background: #1e293b;
            border-radius: 8px;
            border: 1px solid #334155;
            overflow: hidden;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        .waterfall-title {
            background: #1e293b;
            padding: 15px 20px;
            font-weight: 600;
            font-size: 1.05rem;
            color: #f1f5f9;
            border-bottom: 1px solid #334155;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .pathway-count {
            font-size: 0.85rem;
            color: #94a3b8;
            background: #0f172a;
            padding: 4px 8px;
            border-radius: 4px;
        }

        .waterfall-content {
            padding: 20px;
            overflow-y: auto;
            max-height: 700px;
        }

        .waterfall-content::-webkit-scrollbar {
            width: 8px;
        }

        .waterfall-content::-webkit-scrollbar-track {
            background: #1e293b;
        }

        .waterfall-content::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 4px;
        }

        .waterfall-content::-webkit-scrollbar-thumb:hover {
            background: #64748b;
        }

        .bar {
            cursor: pointer;
            transition: all 0.2s;
        }

        .bar:hover {
            opacity: 0.8;
            stroke: #f1f5f9;
            stroke-width: 1px;
        }

        .bar.highlighted {
            stroke: #fbbf24;
            stroke-width: 2px;
        }

        .axis text {
            font-size: 11px;
            fill: #94a3b8;
            /* Slate 400 */
        }

        .axis path,
        .axis line {
            stroke: #475569;
        }

        .axis-label {
            font-weight: 600;
            font-size: 12px;
            fill: #cbd5e0;
        }

        .zero-line {
            stroke: #475569;
            stroke-width: 2;
            stroke-dasharray: 4, 4;
        }

        .legend {
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 20px 30px;
            background: #1e293b;
            border-top: 1px solid #334155;
            flex-wrap: wrap;
            color: #cbd5e0;
        }

        .legend-title {
            font-weight: 600;
            margin-right: 10px;
            font-size: 0.95rem;
            color: #f1f5f9;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
        }

        .legend-box {
            width: 30px;
            height: 15px;
            border-radius: 3px;
        }

        .tooltip {
            position: absolute;
            padding: 12px 16px;
            background: rgba(15, 23, 42, 0.95);
            /* Slate 900 */
            color: #f1f5f9;
            border: 1px solid #334155;
            border-radius: 6px;
            font-size: 0.85rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            max-width: 320px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5);
            line-height: 1.5;
        }

        .tooltip.show {
            opacity: 1;
        }

        .tooltip-pathway {
            font-weight: 700;
            font-size: 0.95rem;
            margin-bottom: 8px;
            color: #818cf8;
        }

        .tooltip-row {
            display: flex;
            justify-content: space-between;
            gap: 15px;
            margin: 4px 0;
        }

        .tooltip-label {
            color: #94a3b8;
        }

        .tooltip-value {
            font-weight: 600;
            color: #f1f5f9;
        }

        .loading {
            text-align: center;
            padding: 60px;
            font-size: 1.1rem;
            color: #718096;
        }

        .value-display {
            font-size: 0.75rem;
            font-weight: 600;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>CellChat Pathway Analysis</h1>
            <div class="subtitle">Cell-Cell Communication: Liver Metastasis vs Adjacent Normal</div>
        </header>



        <div class="controls">
            <div class="control-group">
                <label for="analysisMode">Analysis Mode:</label>
                <select id="analysisMode">
                    <option value="single" selected>Single Species</option>
                    <option value="comparison">Comparison Mode</option>
                </select>
            </div>

            <div class="control-group" id="speciesGroup">
                <label for="species">Species:</label>
                <select id="species">
                    <option value="human" selected>Human Metastasis</option>
                    <option value="mouse">Mouse Metastasis</option>
                </select>
            </div>

            <div class="control-group">
                <label for="cellType">Cell Type:</label>
                <select id="cellType">
                    <option value="All" selected>All Cell Types (Average)</option>
                </select>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="enableCommCell" onchange="toggleCommCell()">
                    Communicating Cell
                </label>
            </div>

            <div class="control-group" id="commCellGroup" style="display: none;">
                <label for="commCell">Partner:</label>
                <select id="commCell" disabled>
                    <option value="">Select partner cell...</option>
                </select>
            </div>

            <div class="control-group">
                <label for="minChange">Min % Change:</label>
                <input type="number" id="minChange" min="0" max="500" step="5" value="10" style="width: 100px;">
            </div>

            <div class="control-group">
                <label for="maxChange">Max % Change:</label>
                <input type="number" id="maxChange" min="0" max="1000" step="10" value="1000" style="width: 110px;">
            </div>

            <div class="control-group">
                <label for="topN">Top N Pathways:</label>
                <select id="topN">
                    <option value="10">Top 10</option>
                    <option value="20">Top 20</option>
                    <option value="30" selected>Top 30</option>
                    <option value="50">Top 50</option>
                    <option value="1000">All</option>
                </select>
            </div>

            <div class="control-group">
                <label for="direction">Show:</label>
                <select id="direction">
                    <option value="all">All Changes</option>
                    <option value="gain">Gains Only (LM > AN)</option>
                    <option value="loss">Losses Only (LM < AN)</option>
                </select>
            </div>

            <div class="control-group">
                <label>
                    <input type="checkbox" id="compiled" onchange="renderComparisonWaterfalls()">
                    Compiled View
                </label>
            </div>

            <div class="control-group" id="concordantGroup" style="display:none; margin-top: 10px;">
                <label title="Show pathways where sgp130 and Human change in the SAME direction">
                    <input type="checkbox" id="concordantMode">
                    Show Concordant (Same Direction)
                </label>
            </div>

            <button class="btn" onclick="resetFilters()">Reset Filters</button>
        </div>

        <div class="waterfalls-container" id="waterfalls">
            <div class="loading">Loading CellChat data...</div>
        </div>

        <div class="legend">
            <span class="legend-title">Color Legend:</span>
            <div class="legend-item">
                <div class="legend-box" style="background: #10b981;"></div>
                <span>Gained in Liver Metastasis (LM > AN)</span>
            </div>
            <div class="legend-item">
                <div class="legend-box" style="background: #ef4444;"></div>
                <span>Lost in Liver Metastasis (LM < AN)</span>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        let datasets = {
            incomingAN: null,
            outgoingAN: null,
            incomingLM: null,
            outgoingLM: null
        };

        // Comparison mode datasets
        let comparisonDatasets = {
            human: {
                incomingAN: null,
                outgoingAN: null,
                incomingLM: null,
                outgoingLM: null
            },
            mouse: {
                incomingAN: null,
                outgoingAN: null,
                incomingLM: null,
                outgoingLM: null
            }
        };

        let cellTypes = [];
        let cellTypeChanges = null;
        let comparisonResults = null;
        let selectedPathway = null;


        async function loadData() {
            try {
                const species = document.getElementById('species').value;

                // Determine file paths based on species
                let paths = {};
                if (species === 'human') {
                    paths = {
                        incomingAN: 'data/cellchat/incomingPathwaysAN.csv',
                        outgoingAN: 'data/cellchat/outgoingPathwaysAN.csv',
                        incomingLM: 'data/cellchat/incomingPathwaysLM.csv',
                        outgoingLM: 'data/cellchat/outgoingPathwaysLM.csv'
                    };
                } else { // mouse
                    paths = {
                        incomingAN: 'data/cellchat/mouse/SgpPathwayPlotValuesIncoming_oct.csv',
                        outgoingAN: 'data/cellchat/mouse/SgpPathwayPlotValuesOutgoing_oct.csv',
                        incomingLM: 'data/cellchat/mouse/WTPathwayPlotValuesIncoming_oct.csv',
                        outgoingLM: 'data/cellchat/mouse/WTPathwayPlotValuesOutgoing_oct.csv'
                    };
                }

                const [incomingAN, outgoingAN, incomingLM, outgoingLM] = await Promise.all([
                    d3.csv(paths.incomingAN),
                    d3.csv(paths.outgoingAN),
                    d3.csv(paths.incomingLM),
                    d3.csv(paths.outgoingLM)
                ]);

                datasets.incomingAN = incomingAN;
                datasets.outgoingAN = outgoingAN;
                datasets.incomingLM = incomingLM;
                datasets.outgoingLM = outgoingLM;

                // Extract cell types from data
                const rawCellTypes = Object.keys(incomingAN[0]).filter(k => k !== '');

                // Populate cell type dropdown based on species
                populateCellTypeDropdowns(species, rawCellTypes);

                calculateCellTypeChanges();
                renderWaterfalls();

            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('waterfalls').innerHTML =
                    '<div class="loading" style="color: #f56565;">Error loading data. Please check file paths.</div>';
            }
        }

        function populateCellTypeDropdowns(species, rawCellTypes) {
            const cellTypeSelect = document.getElementById('cellType');
            const commCellSelect = document.getElementById('commCell');

            // Clear existing options except "All"
            cellTypeSelect.innerHTML = '<option value="All" selected>All Cell Types (Average)</option>';
            commCellSelect.innerHTML = '<option value="">Select partner cell...</option>';

            if (species === 'mouse') {
                // Add merged Macrophage option first
                addCellTypeOption(cellTypeSelect, 'Macrophage');
                addCellTypeOption(commCellSelect, 'Macrophage');

                // Store raw cell types for averaging
                cellTypes = rawCellTypes;

                // Add all individual cell types
                rawCellTypes.forEach(ct => {
                    addCellTypeOption(cellTypeSelect, ct);
                    addCellTypeOption(commCellSelect, ct);
                });
            } else {
                // Human: add all cell types normally
                cellTypes = rawCellTypes;
                rawCellTypes.forEach(ct => {
                    addCellTypeOption(cellTypeSelect, ct);
                    addCellTypeOption(commCellSelect, ct);
                });
            }
        }

        function addCellTypeOption(selectElement, cellType) {
            const option = document.createElement('option');
            option.value = cellType;
            option.textContent = cellType;
            selectElement.appendChild(option);
        }


        function getCellValue(dataset, pathway, cellType) {
            const species = document.getElementById('species').value;
            const row = dataset.find(d => d[''] === pathway);

            // For mouse species and "Macrophage" selection, merge the 3 subtypes
            if (species === 'mouse' && cellType === 'Macrophage') {
                const c1q = parseFloat(row?.['C1q Macrophage']) || 0;
                const spp1 = parseFloat(row?.['Spp1 Macrophage']) || 0;
                const angio = parseFloat(row?.['Angio Macrophage']) || 0;
                return (c1q + spp1 + angio) / 3;
            }

            // For all other cases, return the cell type value directly
            return parseFloat(row?.[cellType]) || 0;
        }

        async function loadComparisonData() {
            try {
                // Load ALL 8 CSV files (4 human + 4 mouse) in parallel
                const [
                    humanInAN, humanOutAN, humanInLM, humanOutLM,
                    mouseInAN, mouseOutAN, mouseInLM, mouseOutLM
                ] = await Promise.all([
                    d3.csv('data/cellchat/incomingPathwaysAN.csv'),
                    d3.csv('data/cellchat/outgoingPathwaysAN.csv'),
                    d3.csv('data/cellchat/incomingPathwaysLM.csv'),
                    d3.csv('data/cellchat/outgoingPathwaysLM.csv'),
                    d3.csv('data/cellchat/mouse/SgpPathwayPlotValuesIncoming_oct.csv'),
                    d3.csv('data/cellchat/mouse/SgpPathwayPlotValuesOutgoing_oct.csv'),
                    d3.csv('data/cellchat/mouse/WTPathwayPlotValuesIncoming_oct.csv'),
                    d3.csv('data/cellchat/mouse/WTPathwayPlotValuesOutgoing_oct.csv')
                ]);

                comparisonDatasets.human = {
                    incomingAN: humanInAN,
                    outgoingAN: humanOutAN,
                    incomingLM: humanInLM,
                    outgoingLM: humanOutLM
                };

                comparisonDatasets.mouse = {
                    incomingAN: mouseInAN,
                    outgoingAN: mouseOutAN,
                    incomingLM: mouseInLM,
                    outgoingLM: mouseOutLM
                };

                // Populate cell types with shared cells only
                populateSharedCellTypes();

                calculateComparisonChanges();
                renderComparisonWaterfalls();

            } catch (error) {
                console.error('Error loading comparison data:', error);
                document.getElementById('waterfalls').innerHTML =
                    '<div class="loading" style="color: #f56565;">Error loading comparison data. Please check file paths.</div>';
            }
        }

        function getComparisonCellValue(dataset, pathway, cellType, species) {
            const row = dataset.find(d => d[''] === pathway);

            // For mouse species and "Macrophage" selection, merge the 3 subtypes
            if (species === 'mouse' && cellType === 'Macrophage') {
                const c1q = parseFloat(row?.['C1q Macrophage']) || 0;
                const spp1 = parseFloat(row?.['Spp1 Macrophage']) || 0;
                const angio = parseFloat(row?.['Angio Macrophage']) || 0;
                return (c1q + spp1 + angio) / 3;
            }

            // For all other cases, return the cell type value directly
            return parseFloat(row?.[cellType]) || 0;
        }

        function populateSharedCellTypes() {
            const cellTypeSelect = document.getElementById('cellType');
            cellTypeSelect.innerHTML = '<option value="">Select cell type...</option>';

            // Get cell types from both species
            const humanCells = Object.keys(comparisonDatasets.human.incomingAN[0]).filter(k => k !== '');
            const mouseCells = Object.keys(comparisonDatasets.mouse.incomingAN[0]).filter(k => k !== '');

            const shared = new Set();

            // Find common cells
            humanCells.forEach(hCell => {
                if (mouseCells.includes(hCell)) {
                    shared.add(hCell);
                }
            });

            // Add Macrophage if mouse has macrophage subtypes
            if (mouseCells.includes('C1q Macrophage') ||
                mouseCells.includes('Spp1 Macrophage') ||
                mouseCells.includes('Angio Macrophage')) {
                if (humanCells.includes('Macrophage')) {
                    shared.add('Macrophage');
                }
            }

            // Populate dropdown with shared cells
            Array.from(shared).sort().forEach(ct => {
                const option = document.createElement('option');
                option.value = ct;
                option.textContent = ct;
                cellTypeSelect.appendChild(option);
            });
        }

        function calculateComparisonChanges() {
            const selectedCellType = document.getElementById('cellType').value;
            if (!selectedCellType) return;

            // Get shared pathways
            const humanPathways = comparisonDatasets.human.incomingAN.map(d => d['']).filter(p => p);
            const mousePathways = comparisonDatasets.mouse.incomingAN.map(d => d['']).filter(p => p);
            const sharedPathways = humanPathways.filter(p => mousePathways.includes(p));

            comparisonResults = {
                incoming: [],
                outgoing: []
            };

            // Calculate for incoming
            sharedPathways.forEach(pathway => {
                // Mouse changes (WT vs sgp130)
                const mouseInWT = getComparisonCellValue(comparisonDatasets.mouse.incomingLM, pathway, selectedCellType, 'mouse');
                const mouseInSgp = getComparisonCellValue(comparisonDatasets.mouse.incomingAN, pathway, selectedCellType, 'mouse');
                const mouseInChange = mouseInSgp !== 0 ? ((mouseInWT - mouseInSgp) / mouseInSgp) * 100 : 0;

                // Human changes (LM vs AN)
                const humanInLM = getComparisonCellValue(comparisonDatasets.human.incomingLM, pathway, selectedCellType, 'human');
                const humanInAN = getComparisonCellValue(comparisonDatasets.human.incomingAN, pathway, selectedCellType, 'human');
                const humanInChange = humanInAN !== 0 ? ((humanInLM - humanInAN) / humanInAN) * 100 : 0;

                // Categorize
                let category = null;
                if (mouseInChange < 0 && humanInChange > 0) category = 'il6-dependent'; // Inverse 1
                else if (mouseInChange > 0 && humanInChange < 0) category = 'anti-tumor'; // Inverse 2
                else if (mouseInChange > 0 && humanInChange > 0) category = 'concordant-up'; // Same Up
                else if (mouseInChange < 0 && humanInChange < 0) category = 'concordant-down'; // Same Down

                if (category) {
                    comparisonResults.incoming.push({
                        pathway,
                        mouseChange: mouseInChange,
                        humanChange: humanInChange,
                        mouseWT: mouseInWT,
                        mouseSgp: mouseInSgp,
                        humanLM: humanInLM,
                        humanAN: humanInAN,
                        category: category
                    });
                }
            });

            // Calculate for outgoing
            sharedPathways.forEach(pathway => {
                const mouseOutWT = getComparisonCellValue(comparisonDatasets.mouse.outgoingLM, pathway, selectedCellType, 'mouse');
                const mouseOutSgp = getComparisonCellValue(comparisonDatasets.mouse.outgoingAN, pathway, selectedCellType, 'mouse');
                const mouseOutChange = mouseOutSgp !== 0 ? ((mouseOutWT - mouseOutSgp) / mouseOutSgp) * 100 : 0;

                const humanOutLM = getComparisonCellValue(comparisonDatasets.human.outgoingLM, pathway, selectedCellType, 'human');
                const humanOutAN = getComparisonCellValue(comparisonDatasets.human.outgoingAN, pathway, selectedCellType, 'human');
                const humanOutChange = humanOutAN !== 0 ? ((humanOutLM - humanOutAN) / humanOutAN) * 100 : 0;

                let category = null;
                if (mouseOutChange < 0 && humanOutChange > 0) category = 'il6-dependent';
                else if (mouseOutChange > 0 && humanOutChange < 0) category = 'anti-tumor';
                else if (mouseOutChange > 0 && humanOutChange > 0) category = 'concordant-up';
                else if (mouseOutChange < 0 && humanOutChange < 0) category = 'concordant-down';

                if (category) {
                    comparisonResults.outgoing.push({
                        pathway,
                        mouseChange: mouseOutChange,
                        humanChange: humanOutChange,
                        mouseWT: mouseOutWT,
                        mouseSgp: mouseOutSgp,
                        humanLM: humanOutLM,
                        humanAN: humanOutAN,
                        category: category
                    });
                }
            });
        }

        function calculateCellTypeChanges() {
            const pathways = datasets.incomingAN.map(d => d['']).filter(p => p);
            const selectedCellType = document.getElementById('cellType').value;

            cellTypeChanges = {
                incoming: [],
                outgoing: []
            };

            pathways.forEach(pathway => {
                let anIn, lmIn, anOut, lmOut;

                if (selectedCellType === 'All') {
                    // Average across all cell types
                    const incomingRow = datasets.incomingAN.find(d => d[''] === pathway);
                    const incomingLMRow = datasets.incomingLM.find(d => d[''] === pathway);
                    const outgoingRow = datasets.outgoingAN.find(d => d[''] === pathway);
                    const outgoingLMRow = datasets.outgoingLM.find(d => d[''] === pathway);

                    anIn = cellTypes.reduce((sum, ct) => sum + (parseFloat(incomingRow?.[ct]) || 0), 0) / cellTypes.length;
                    lmIn = cellTypes.reduce((sum, ct) => sum + (parseFloat(incomingLMRow?.[ct]) || 0), 0) / cellTypes.length;
                    anOut = cellTypes.reduce((sum, ct) => sum + (parseFloat(outgoingRow?.[ct]) || 0), 0) / cellTypes.length;
                    lmOut = cellTypes.reduce((sum, ct) => sum + (parseFloat(outgoingLMRow?.[ct]) || 0), 0) / cellTypes.length;
                } else {
                    // Check if communicating cell filter is enabled
                    const commCellEnabled = document.getElementById('enableCommCell').checked;
                    const commCell = document.getElementById('commCell').value;

                    if (commCellEnabled && commCell) {
                        // Cell-to-cell specific communication
                        // INCOMING: selectedCell receives <- commCell sends
                        const selectedInAN = getCellValue(datasets.incomingAN, pathway, selectedCellType);
                        const selectedInLM = getCellValue(datasets.incomingLM, pathway, selectedCellType);
                        const commOutAN = getCellValue(datasets.outgoingAN, pathway, commCell);
                        const commOutLM = getCellValue(datasets.outgoingLM, pathway, commCell);

                        // Average both values for communication score
                        anIn = (selectedInAN + commOutAN) / 2;
                        lmIn = (selectedInLM + commOutLM) / 2;

                        // OUTGOING: selectedCell sends -> commCell receives
                        const selectedOutAN = getCellValue(datasets.outgoingAN, pathway, selectedCellType);
                        const selectedOutLM = getCellValue(datasets.outgoingLM, pathway, selectedCellType);
                        const commInAN = getCellValue(datasets.incomingAN, pathway, commCell);
                        const commInLM = getCellValue(datasets.incomingLM, pathway, commCell);

                        // Average both values for communication score
                        anOut = (selectedOutAN + commInAN) / 2;
                        lmOut = (selectedOutLM + commInLM) / 2;
                    } else {
                        // Specific cell type (normal mode)
                        anIn = getCellValue(datasets.incomingAN, pathway, selectedCellType);
                        lmIn = getCellValue(datasets.incomingLM, pathway, selectedCellType);
                        anOut = getCellValue(datasets.outgoingAN, pathway, selectedCellType);
                        lmOut = getCellValue(datasets.outgoingLM, pathway, selectedCellType);
                    }
                }

                if (anIn > 0 || lmIn > 0) {
                    const change = lmIn - anIn;
                    const percentChange = anIn > 0 ? (change / anIn) * 100 : (lmIn > 0 ? 100 : 0);

                    cellTypeChanges.incoming.push({
                        pathway,
                        an: anIn,
                        lm: lmIn,
                        change: change,
                        percentChange: percentChange,
                        foldChange: anIn > 0 ? lmIn / anIn : (lmIn > 0 ? Infinity : 0)
                    });
                }

                if (anOut > 0 || lmOut > 0) {
                    const change = lmOut - anOut;
                    const percentChange = anOut > 0 ? (change / anOut) * 100 : (lmOut > 0 ? 100 : 0);

                    cellTypeChanges.outgoing.push({
                        pathway,
                        an: anOut,
                        lm: lmOut,
                        change: change,
                        percentChange: percentChange,
                        foldChange: anOut > 0 ? lmOut / anOut : (lmOut > 0 ? Infinity : 0)
                    });
                }
            });

            // Sort by percent change: positive (gains) first, descending
            cellTypeChanges.incoming.sort((a, b) => b.percentChange - a.percentChange);
            cellTypeChanges.outgoing.sort((a, b) => b.percentChange - a.percentChange);
        }

        function filterData(data) {
            const minChange = parseFloat(document.getElementById('minChange').value);
            const maxChange = parseFloat(document.getElementById('maxChange').value);
            const topN = parseInt(document.getElementById('topN').value);
            const direction = document.getElementById('direction').value;

            let filtered = data.filter(d => {
                const absChange = Math.abs(d.percentChange);
                return absChange >= minChange && absChange <= maxChange;
            });

            if (direction === 'gain') {
                filtered = filtered.filter(d => d.change > 0);
            } else if (direction === 'loss') {
                filtered = filtered.filter(d => d.change < 0);
            }

            return filtered.slice(0, topN);
        }

        function renderWaterfalls() {
            const container = document.getElementById('waterfalls');
            container.innerHTML = '';

            const selectedCellType = document.getElementById('cellType').value;
            const commCellEnabled = document.getElementById('enableCommCell').checked;
            const commCell = document.getElementById('commCell').value;

            const incomingFiltered = filterData(cellTypeChanges.incoming);
            const outgoingFiltered = filterData(cellTypeChanges.outgoing);

            // Determine titles based on communicating cell filter
            let incomingTitle, outgoingTitle;

            if (commCellEnabled && commCell) {
                // Show directional arrows for cell-to-cell communication
                incomingTitle = `${selectedCellType} ← ${commCell}`;
                outgoingTitle = `${selectedCellType} → ${commCell}`;
            } else {
                // Default titles
                incomingTitle = 'Incoming Pathways';
                outgoingTitle = 'Outgoing Pathways';
            }

            renderWaterfall(incomingFiltered, 'incoming-waterfall', incomingTitle);
            renderWaterfall(outgoingFiltered, 'outgoing-waterfall', outgoingTitle);
        }

        function renderComparisonWaterfalls() {
            const container = document.getElementById('waterfalls');
            container.innerHTML = '';

            if (!comparisonResults || !comparisonResults.incoming) {
                container.innerHTML = '<div class="loading">Please select a cell type to begin comparison</div>';
                return;
            }

            // Apply filters
            const minChange = parseFloat(document.getElementById('minChange').value) || 0;
            const maxChange = parseFloat(document.getElementById('maxChange').value) || 1000;
            const topN = parseInt(document.getElementById('topN').value) || 50;
            const direction = document.getElementById('direction').value || 'all';
            const showConcordant = document.getElementById('concordantMode').checked;

            function applyFilters(data) {
                return data.filter(d => {
                    const absMouseChange = Math.abs(d.mouseChange);
                    const absHumanChange = Math.abs(d.humanChange);

                    // Min/max filters on BOTH species
                    if (absMouseChange < minChange || absHumanChange < minChange) return false;
                    if (absMouseChange > maxChange || absHumanChange > maxChange) return false;

                    // Mode Filter (Inverse vs Concordant)
                    const isConcordant = d.category.startsWith('concordant');
                    if (showConcordant && !isConcordant) return false;
                    if (!showConcordant && isConcordant) return false;

                    //Direction filter (modified for concordant)
                    if (direction === 'gains') {
                        if (!showConcordant && d.category !== 'anti-tumor') return false;
                        if (showConcordant && d.category !== 'concordant-up') return false;
                    }
                    if (direction === 'losses') {
                        if (!showConcordant && d.category !== 'il6-dependent') return false;
                        if (showConcordant && d.category !== 'concordant-down') return false;
                    }

                    return true;
                }).slice(0, topN);
            }

            const incomingFiltered = applyFilters(comparisonResults.incoming);
            const outgoingFiltered = applyFilters(comparisonResults.outgoing);

            // Check if compiled mode is enabled
            const isCompiled = document.getElementById('compiled').checked;

            if (isCompiled) {
                // Compiled view: 2 plots (incoming, outgoing) with grouped bars
                renderCompiledView(container, incomingFiltered, 'Incoming Pathways');
                renderCompiledView(container, outgoingFiltered, 'Outgoing Pathways');
            } else {
                // Standard view: 4 plots (mouse incoming/outgoing, human incoming/outgoing)
                // Grid container for side-by-side waterfalls
                const gridContainer = document.createElement('div');
                gridContainer.style.display = 'grid';
                gridContainer.style.gridTemplateColumns = 'repeat(auto-fit, minmax(450px, 1fr))';
                gridContainer.style.gap = '30px';
                gridContainer.style.marginBottom = '40px';

                // Render incoming comparison
                renderComparisonPair(gridContainer, incomingFiltered, 'Incoming Pathways');

                container.appendChild(gridContainer);

                // Render outgoing comparison
                const gridContainer2 = document.createElement('div');
                gridContainer2.style.display = 'grid';
                gridContainer2.style.gridTemplateColumns = 'repeat(auto-fit, minmax(450px, 1fr))';
                gridContainer2.style.gap = '30px';

                renderComparisonPair(gridContainer2, outgoingFiltered, 'Outgoing Pathways');

                container.appendChild(gridContainer2);
            }
        }

        function renderComparisonPair(container, data, title) {
            if (data.length === 0) {
                const noData = document.createElement('div');
                noData.colSpan = 2;
                noData.innerHTML = `<div class="loading">No pathways match filters for ${title}</div>`;
                container.appendChild(noData);
                return;
            }

            // Sort by algebraic mouse change (Descending: Positive -> Negative)
            const sorted = [...data].sort((a, b) => b.mouseChange - a.mouseChange);





            // Mouse waterfall
            const mouseSection = document.createElement('div');
            mouseSection.className = 'waterfall-section';
            mouseSection.innerHTML = `
                <div class="waterfall-title">
                    Mouse (sgp130 vs WT) - ${title}
                    <span class="pathway-count">${sorted.length} pathways</span>
                </div>
            `;

            renderComparisonWaterfall(mouseSection, sorted, 'mouse');
            container.appendChild(mouseSection);

            // Human waterfall
            const humanSection = document.createElement('div');
            humanSection.className = 'waterfall-section';
            humanSection.innerHTML = `
                <div class="waterfall-title">
                    Human (LM vs AN) - ${title}
                    <span class="pathway-count">${sorted.length} pathways</span>
                </div>
            `;

            renderComparisonWaterfall(humanSection, sorted, 'human');
            container.appendChild(humanSection);
        }

        function renderComparisonWaterfall(container, data, species) {
            const margin = { top: 20, right: 80, bottom: 40, left: 160 };
            const barHeight = 28;
            const height = data.length * barHeight + margin.top + margin.bottom;
            const width = 650;

            const svg = d3.select(container)
                .append('svg')
                .attr('width', '100%')
                .attr('viewBox', `0 0 ${width} ${height}`)
                .style('max-width', '100%')
                .style('height', 'auto');

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Get change values based on species
            const changes = data.map(d => species === 'mouse' ? d.mouseChange : d.humanChange);
            const maxAbs = d3.max(changes.map(Math.abs)) || 100;

            const x = d3.scaleLinear()
                .domain([-maxAbs, maxAbs])
                .range([0, width - margin.left - margin.right]);

            const y = d3.scaleBand()
                .domain(data.map((d, i) => i))
                .range([0, data.length * barHeight])
                .padding(0.15);

            // Bars
            g.selectAll('.bar')
                .data(data)
                .enter()
                .append('rect')
                .attr('class', d => {
                    const change = species === 'mouse' ? d.mouseChange : d.humanChange;
                    return `bar pathway-${d.pathway.replace(/[^a-zA-Z0-9]/g, '_')}`;
                })
                .attr('x', d => {
                    const change = species === 'mouse' ? d.mouseChange : d.humanChange;
                    return change < 0 ? x(change) : x(0);
                })
                .attr('y', (d, i) => y(i))
                .attr('width', d => {
                    const change = species === 'mouse' ? d.mouseChange : d.humanChange;
                    return Math.abs(x(change) - x(0));
                })
                .attr('height', y.bandwidth())
                .attr('fill', d => {
                    const change = species === 'mouse' ? d.mouseChange : d.humanChange;
                    return change > 0 ? '#48bb78' : '#f56565';
                })
                .attr('opacity', 0.8)
                .on('click', (event, d) => selectPathway(d.pathway))
                .on('mouseover', (event, d) => showComparisonTooltip(event, d, species))
                .on('mouseout', hideTooltip);

            // Labels (Pathway Names) - Aligned to the axis with padding for values
            g.selectAll('.label')
                .data(data)
                .enter()
                .append('text')
                .attr('class', 'label')
                .attr('x', -60) // Closer to axis, leaving space for value labels
                .attr('y', (d, i) => y(i) + y.bandwidth() / 2)
                .attr('dy', '0.35em')
                .attr('text-anchor', 'end') // Align end to sit next to the gap
                .style('font-size', '12px')
                .style('fill', '#f1f5f9')
                .style('font-weight', '500')
                .text(d => d.pathway);

            // Value labels
            g.selectAll('.value')
                .data(data)
                .enter()
                .append('text')
                .attr('class', 'value')
                .attr('x', d => {
                    const change = species === 'mouse' ? d.mouseChange : d.humanChange;
                    return change > 0 ? x(change) + 5 : x(change) - 5;
                })
                .attr('y', (d, i) => y(i) + y.bandwidth() / 2)
                .attr('dy', '0.35em')
                .attr('text-anchor', d => {
                    const change = species === 'mouse' ? d.mouseChange : d.humanChange;
                    return change > 0 ? 'start' : 'end';
                })
                .style('font-size', '11px')
                .style('fill', '#f1f5f9')
                .style('font-weight', '600')
                .text(d => {
                    const change = species === 'mouse' ? d.mouseChange : d.humanChange;
                    return (change > 0 ? '+' : '') + change.toFixed(1) + '%';
                });

            // Zero line
            g.append('line')
                .attr('x1', x(0))
                .attr('x2', x(0))
                .attr('y1', 0)
                .attr('y2', data.length * barHeight)
                .attr('stroke', '#475569')
                .attr('stroke-width', 2);

            // X-axis
            g.append('g')
                .attr('transform', `translate(0,${data.length * barHeight})`)
                .call(d3.axisBottom(x).ticks(5).tickFormat(d => d + '%'))
                .style('font-size', '12px');
        }

        // COMPILED VIEW FUNCTIONS
        function renderCompiledView(container, data, title) {
            if (data.length === 0) {
                const noData = document.createElement('div');
                noData.innerHTML = `<div class="loading">No pathways match filters for ${title}</div>`;
                container.appendChild(noData);
                return;
            }

            // Sort by absolute mouse change (descending)
            const sorted = [...data].sort((a, b) => b.mouseChange - a.mouseChange);

            // Create section
            const section = document.createElement('div');
            section.className = 'waterfall-section';
            section.style.marginBottom = '40px';
            section.innerHTML = `
                <div class="waterfall-title">
                    Cross-Species Comparison - ${title}
                    <span class="pathway-count">${sorted.length} pathways</span>
                </div>
            `;

            renderCompiledWaterfall(section, sorted);
            container.appendChild(section);
        }

        function renderCompiledWaterfall(container, data) {
            const margin = { top: 60, right: 100, bottom: 40, left: 160 };
            const barHeight = 12; // Height per bar (2 bars per pathway = 24px total)
            const groupPadding = 4; // Padding between bars in a group
            const groupHeight = (barHeight * 2) + groupPadding;
            const height = data.length * groupHeight + margin.top + margin.bottom;
            const width = 700;

            const svg = d3.select(container)
                .append('svg')
                .attr('width', '100%')
                .attr('viewBox', `0 0 ${width} ${height}`)
                .style('max-width', '100%')
                .style('height', 'auto');

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Get all changes for scale
            const allChanges = data.flatMap(d => [d.mouseChange, d.humanChange]);
            const maxAbs = d3.max(allChanges.map(Math.abs)) || 100;

            const x = d3.scaleLinear()
                .domain([-maxAbs, maxAbs])
                .range([0, width - margin.left - margin.right]);

            const y = d3.scaleLinear()
                .domain([0, data.length])
                .range([0, data.length * groupHeight]);

            // Add legend at the top
            const legend = svg.append('g')
                .attr('transform', `translate(${margin.left}, 20)`);

            legend.append('rect')
                .attr('x', 0)
                .attr('y', 0)
                .attr('width', 14)
                .attr('height', 14)
                .attr('fill', '#3b82f6')
                .attr('opacity', 0.8);

            legend.append('text')
                .attr('x', 20)
                .attr('y', 12)
                .style('font-size', '13px')
                .style('fill', '#f1f5f9')
                .text('Human (LM vs AN)');

            legend.append('rect')
                .attr('x', 180)
                .attr('y', 0)
                .attr('width', 14)
                .attr('height', 14)
                .attr('fill', '#f97316')
                .attr('opacity', 0.8);

            legend.append('text')
                .attr('x', 200)
                .attr('y', 12)
                .style('font-size', '13px')
                .style('fill', '#f1f5f9')
                .text('Mouse (sgp130 vs WT)');

            // Mouse bars (top bar in each group)
            g.selectAll('.bar-mouse')
                .data(data)
                .enter()
                .append('rect')
                .attr('class', 'bar bar-mouse')
                .attr('x', d => d.mouseChange < 0 ? x(d.mouseChange) : x(0))
                .attr('y', (d, i) => y(i))
                .attr('width', d => Math.abs(x(d.mouseChange) - x(0)))
                .attr('height', barHeight)
                .attr('fill', '#f97316') // Orange for mouse
                .attr('opacity', 0.8)
                .on('click', (event, d) => selectPathway(d.pathway))
                .on('mouseover', (event, d) => showCompiledTooltip(event, d, 'mouse'))
                .on('mouseout', hideTooltip);

            // Human bars (bottom bar in each group)
            g.selectAll('.bar-human')
                .data(data)
                .enter()
                .append('rect')
                .attr('class', 'bar bar-human')
                .attr('x', d => d.humanChange < 0 ? x(d.humanChange) : x(0))
                .attr('y', (d, i) => y(i) + barHeight + groupPadding)
                .attr('width', d => Math.abs(x(d.humanChange) - x(0)))
                .attr('height', barHeight)
                .attr('fill', '#3b82f6') // Blue for human
                .attr('opacity', 0.8)
                .on('click', (event, d) => selectPathway(d.pathway))
                .on('mouseover', (event, d) => showCompiledTooltip(event, d, 'human'))
                .on('mouseout', hideTooltip);

            // Pathway labels (one per group, centered vertically)
            g.selectAll('.label')
                .data(data)
                .enter()
                .append('text')
                .attr('class', 'label')
                .attr('x', -60)
                .attr('y', (d, i) => y(i) + groupHeight / 2)
                .attr('dy', '0.35em')
                .attr('text-anchor', 'end')
                .style('font-size', '11px')
                .style('fill', '#f1f5f9')
                .style('font-weight', '500')
                .text(d => d.pathway);

            // Value labels for mouse
            g.selectAll('.value-mouse')
                .data(data)
                .enter()
                .append('text')
                .attr('class', 'value-mouse')
                .attr('x', d => d.mouseChange > 0 ? x(d.mouseChange) + 5 : x(d.mouseChange) - 5)
                .attr('y', (d, i) => y(i) + barHeight / 2)
                .attr('dy', '0.35em')
                .attr('text-anchor', d => d.mouseChange > 0 ? 'start' : 'end')
                .style('font-size', '10px')
                .style('fill', '#f1f5f9')
                .style('font-weight', '600')
                .text(d => (d.mouseChange > 0 ? '+' : '') + d.mouseChange.toFixed(1) + '%');

            // Value labels for human
            g.selectAll('.value-human')
                .data(data)
                .enter()
                .append('text')
                .attr('class', 'value-human')
                .attr('x', d => d.humanChange > 0 ? x(d.humanChange) + 5 : x(d.humanChange) - 5)
                .attr('y', (d, i) => y(i) + barHeight + groupPadding + barHeight / 2)
                .attr('dy', '0.35em')
                .attr('text-anchor', d => d.humanChange > 0 ? 'start' : 'end')
                .style('font-size', '10px')
                .style('fill', '#f1f5f9')
                .style('font-weight', '600')
                .text(d => (d.humanChange > 0 ? '+' : '') + d.humanChange.toFixed(1) + '%');

            // Zero line
            g.append('line')
                .attr('x1', x(0))
                .attr('x2', x(0))
                .attr('y1', 0)
                .attr('y2', data.length * groupHeight)
                .attr('stroke', '#475569')
                .attr('stroke-width', 2);

            // X-axis
            g.append('g')
                .attr('transform', `translate(0,${data.length * groupHeight})`)
                .call(d3.axisBottom(x).ticks(5).tickFormat(d => d + '%'))
                .style('font-size', '12px');
        }

        function showCompiledTooltip(event, d, species) {
            const tooltip = document.getElementById('tooltip');
            const change = species === 'mouse' ? d.mouseChange : d.humanChange;
            const speciesLabel = species === 'mouse' ? 'Mouse (sgp130 vs WT)' : 'Human (LM vs AN)';
            const baseline = species === 'mouse' ? d.mouseSgp : d.humanAN;
            const target = species === 'mouse' ? d.mouseWT : d.humanLM;
            const baselineLabel = species === 'mouse' ? 'sgp130' : 'AN';
            const targetLabel = species === 'mouse' ? 'WT' : 'LM';

            tooltip.innerHTML = `
                <strong>${d.pathway}</strong><br>
                <strong>${speciesLabel}:</strong><br>
                ${baselineLabel}: ${baseline.toFixed(3)}<br>
                ${targetLabel}: ${target.toFixed(3)}<br>
                Change: ${(change > 0 ? '+' : '')}${change.toFixed(1)}%
            `;
            tooltip.style.left = event.pageX + 10 + 'px';
            tooltip.style.top = event.pageY + 10 + 'px';
            tooltip.classList.add('show');
        }

        function showComparisonTooltip(event, d, species) {
            const tooltip = document.getElementById('tooltip');
            const mouseChange = d.mouseChange;
            const humanChange = d.humanChange;
            const category = d.category === 'il6-dependent' ? 'IL-6 Dependent (↓Mouse, ↑Human)' :
                d.category === 'anti-tumor' ? 'Anti-tumor (↑Mouse, ↓Human)' :
                    d.category === 'concordant-up' ? 'Concordant Up (↑Mouse, ↑Human)' :
                        'Concordant Down (↓Mouse, ↓Human)';

            tooltip.innerHTML = `
                <strong>${d.pathway}</strong><br>
                <strong>Category:</strong> ${category}<br><br>
                <strong>Mouse (sgp130/WT):</strong><br>
                sgp130: ${d.mouseSgp.toFixed(3)}<br>
                WT: ${d.mouseWT.toFixed(3)}<br>
                Change: ${(mouseChange > 0 ? '+' : '')}${mouseChange.toFixed(1)}%<br><br>
                <strong>Human (LM/AN):</strong><br>
                AN: ${d.humanAN.toFixed(3)}<br>
                LM: ${d.humanLM.toFixed(3)}<br>
                Change: ${(humanChange > 0 ? '+' : '')}${humanChange.toFixed(1)}%
            `;
            tooltip.style.left = event.pageX + 10 + 'px';
            tooltip.style.top = event.pageY + 10 + 'px';
            tooltip.classList.add('show');
        }

        function renderWaterfall(data, containerId, title, subtitle) {
            if (data.length === 0) {
                const section = document.createElement('div');
                section.className = 'waterfall-section';
                section.innerHTML = `
                    <div class="waterfall-title">${title}</div>
                    <div class="loading" style="padding: 40px;">No pathways match current filters</div>
                `;
                document.getElementById('waterfalls').appendChild(section);
                return;
            }

            const margin = { top: 20, right: 100, bottom: 40, left: 150 };
            const barHeight = 28;  // Increased from 22 to prevent label overlap
            const height = data.length * barHeight + margin.top + margin.bottom;
            const width = 700;

            const section = document.createElement('div');
            section.className = 'waterfall-section';
            section.innerHTML = `
                <div class="waterfall-title">
                    ${title}
                    <span class="pathway-count">${data.length} pathways</span>
                </div>
                <div class="waterfall-content" id="${containerId}"></div>
            `;
            document.getElementById('waterfalls').appendChild(section);

            const svg = d3.select(`#${containerId}`)
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Scales
            const maxAbsChange = d3.max(data, d => Math.abs(d.percentChange));
            const xScale = d3.scaleLinear()
                .domain([-maxAbsChange, maxAbsChange])
                .range([0, width - margin.left - margin.right]);

            const yScale = d3.scaleBand()
                .domain(data.map(d => d.pathway))
                .range([0, data.length * barHeight])
                .padding(0.2);  // Increased padding from 0.15 to 0.2

            // Zero line
            g.append('line')
                .attr('class', 'zero-line')
                .attr('x1', xScale(0))
                .attr('x2', xScale(0))
                .attr('y1', 0)
                .attr('y2', data.length * barHeight);

            // Bars
            g.selectAll('.bar')
                .data(data)
                .enter()
                .append('rect')
                .attr('class', d => `bar pathway-${d.pathway.replace(/[^a-zA-Z0-9]/g, '_')}`)
                .attr('x', d => d.percentChange > 0 ? xScale(0) : xScale(d.percentChange))
                .attr('y', d => yScale(d.pathway))
                .attr('width', d => Math.abs(xScale(d.percentChange) - xScale(0)))
                .attr('height', yScale.bandwidth())
                .attr('fill', d => d.percentChange > 0 ? '#10b981' : '#ef4444')
                .on('mouseover', (event, d) => showTooltip(event, d))
                .on('mouseout', hideTooltip)
                .on('click', (event, d) => selectPathway(d.pathway));

            // Value labels
            g.selectAll('.value-label')
                .data(data)
                .enter()
                .append('text')
                .attr('class', 'value-display')
                .attr('x', d => d.percentChange > 0 ?
                    xScale(d.percentChange) + 5 : xScale(d.percentChange) - 5)
                .attr('y', d => yScale(d.pathway) + yScale.bandwidth() / 2 + 4)
                .attr('text-anchor', d => d.percentChange > 0 ? 'start' : 'end')
                .attr('fill', '#f1f5f9') // Light text for dark theme
                .style('font-weight', '600')
                .text(d => `${d.percentChange > 0 ? '+' : ''}${d.percentChange.toFixed(1)}%`);

            // Y-axis (pathway labels)
            g.selectAll('.pathway-label')
                .data(data)
                .enter()
                .append('text')
                .attr('class', 'axis')
                .attr('x', -10)
                .attr('y', d => yScale(d.pathway) + yScale.bandwidth() / 2 + 3)
                .attr('text-anchor', 'end')
                .text(d => d.pathway)
                .style('fill', '#cbd5e0') // Light text for dark theme
                .style('font-size', '10px')
                .style('cursor', 'pointer')
                .on('click', (event, d) => selectPathway(d.pathway));

            // X-axis
            const xAxis = d3.axisBottom(xScale)
                .ticks(5)
                .tickFormat(d => `${d}%`);

            g.append('g')
                .attr('class', 'axis')
                .attr('transform', `translate(0,${data.length * barHeight})`)
                .call(xAxis);

            // X-axis label
            g.append('text')
                .attr('class', 'axis-label')
                .attr('x', (width - margin.left - margin.right) / 2)
                .attr('y', data.length * barHeight + 35)
                .attr('text-anchor', 'middle')
                .text('% Change (LM vs AN)');
        }

        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <div class="tooltip-pathway">${d.pathway}</div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Adjacent Normal:</span>
                    <span class="tooltip-value">${d.an.toFixed(3)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Liver Metastasis:</span>
                    <span class="tooltip-value">${d.lm.toFixed(3)}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Change:</span>
                    <span class="tooltip-value" style="color: ${d.change > 0 ? '#10b981' : '#ef4444'}">
                        ${d.change > 0 ? '+' : ''}${d.change.toFixed(3)}
                    </span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">% Change:</span>
                    <span class="tooltip-value" style="color: ${d.percentChange > 0 ? '#10b981' : '#ef4444'}">
                        ${d.percentChange > 0 ? '+' : ''}${d.percentChange.toFixed(1)}%
                    </span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Fold Change:</span>
                    <span class="tooltip-value">${d.foldChange === Infinity ? '∞' : d.foldChange.toFixed(2)}x</span>
                </div>
            `;
            tooltip.style.left = (event.pageX + 15) + 'px';
            tooltip.style.top = (event.pageY - 10) + 'px';
            tooltip.classList.add('show');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('show');
        }

        function selectPathway(pathway) {
            selectedPathway = pathway;
            d3.selectAll('.bar').classed('highlighted', false);
            d3.selectAll(`.pathway-${pathway.replace(/[^a-zA-Z0-9]/g, '_')}`).classed('highlighted', true);
        }

        function toggleCommCell() {
            const enabled = document.getElementById('enableCommCell').checked;
            const selectedCellType = document.getElementById('cellType').value;
            const commCellGroup = document.getElementById('commCellGroup');
            const commCellSelect = document.getElementById('commCell');

            if (enabled && selectedCellType !== 'All') {
                commCellGroup.style.display = 'block';
                commCellSelect.disabled = false;
            } else {
                commCellGroup.style.display = 'none';
                commCellSelect.disabled = true;
                document.getElementById('enableCommCell').checked = false;
            }

            calculateCellTypeChanges();
            renderWaterfalls();
        }

        function resetFilters() {
            const mode = document.getElementById('analysisMode').value;

            // Common resets
            document.getElementById('minChange').value = '10';
            document.getElementById('maxChange').value = '1000';
            document.getElementById('topN').value = '30';
            document.getElementById('direction').value = 'all';
            selectedPathway = null;
            d3.selectAll('.bar').classed('highlighted', false);

            if (mode === 'single') {
                document.getElementById('cellType').value = 'All';
                document.getElementById('enableCommCell').checked = false;
                document.getElementById('commCell').value = '';
                document.getElementById('commCellGroup').style.display = 'none';
                calculateCellTypeChanges();
                renderWaterfalls();
            } else {
                // Comparison mode
                document.getElementById('cellType').value = '';
                renderComparisonWaterfalls();
            }
        }


        // Event listeners
        document.getElementById('analysisMode').addEventListener('change', async () => {
            const mode = document.getElementById('analysisMode').value;

            if (mode === 'comparison') {
                // Hide species selector in comparison mode
                document.getElementById('speciesGroup').style.display = 'none';

                // Hide communicating cell filter
                document.getElementById('enableCommCell').parentElement.style.display = 'none';
                document.getElementById('commCellGroup').style.display = 'none';

                // Show Concordant Toggle
                document.getElementById('concordantGroup').style.display = 'block';

                // Load comparison data
                await loadComparisonData();
            } else {
                // Show species selector
                document.getElementById('speciesGroup').style.display = 'block';

                // Show communicating cell filter
                document.getElementById('enableCommCell').parentElement.style.display = 'block';

                // Hide Concordant Toggle
                document.getElementById('concordantGroup').style.display = 'none';

                // Reload single species data
                await loadData();
            }
        });

        document.getElementById('species').addEventListener('change', async () => {
            // Reload data for the selected species
            await loadData();
            // Reset communicating cell filter
            document.getElementById('enableCommCell').checked = false;
            document.getElementById('commCell').value = '';
            toggleCommCell();
        });

        document.getElementById('cellType').addEventListener('change', () => {
            const selectedCellType = document.getElementById('cellType').value;
            const mode = document.getElementById('analysisMode').value;

            if (selectedCellType === 'All' && mode === 'single') {
                // Disable communicating cell if "All" is selected (only in single mode)
                document.getElementById('enableCommCell').checked = false;
                toggleCommCell();
            }

            // Recalculate based on mode
            if (mode === 'comparison') {
                calculateComparisonChanges();
                renderComparisonWaterfalls();
            } else {
                calculateCellTypeChanges();
                renderWaterfalls();
            }
        });

        document.getElementById('commCell').addEventListener('change', () => {
            calculateCellTypeChanges();
            renderWaterfalls();
        });
        document.getElementById('minChange').addEventListener('change', renderWaterfalls);
        document.getElementById('maxChange').addEventListener('change', renderWaterfalls);
        document.getElementById('topN').addEventListener('change', renderWaterfalls);
        document.getElementById('direction').addEventListener('change', renderWaterfalls);
        document.getElementById('concordantMode').addEventListener('change', renderComparisonWaterfalls);

        // Initialize
        loadData();
    </script>
</body>

</html>